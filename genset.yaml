#genset.yaml
esphome:
  name: genset
  #friendly_name: genmon2

rp2040:
  board: rpipicow

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: "9f6aac9d5e98fb4ba34f158083f13970"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot in case wifi connection fails
  ap:
    ssid: "Blink Fallback Hotspot"
    password: "esphomepw"

  # --- On Connect Action for Internal LED ---
  # Turn it on upon connect, but it will be overridden by status_led
  #on_connect:
    #then:
      #- light.turn_on:
          #id: onboard_led_light
          #brightness: 100% 

# Does not work on pi pico yet
#captive_portal:

#-------------------------------------------------------
# Homeassistant I/O code
#output: 
  
#-------------------------------------------------------

status_led:
  #pin: LED
  pin:
    number: LED
    inverted: true
  

# --- LIGHT COMPONENTS ---
#light: 
  # LIGHT component for Pico W Status LED
  #- platform: status_led
    # The Pico W LED is controlled by the CYW43439 Wi-Fi chip.
    # Pin 32 or Pin LED control it
    #pin: GPIO32 
    #pin: LED 
    #name: "Pico Status LED"
    #id: onboard_led_light

#------------------------------------------------------
# MQTT Integration
#mqtt:
  #id: mqtt_client
  #broker: 172.16.30.41
  #port: 1883
  #username: esphome
  #password: !secret mqtt_password

  # additional params
  #topic_prefix: esphome

# Status configuration (using the documented structure)
  #status:
    #topic: homeassistant/status
    #update_interval: 60s # Publish status every 60 seconds (optional, but good practice)

# Birth message (Sends "online" when connected)
  #birth_message:
    #topic: homeassistant/genset/status
    #payload: "online"
    #qos: 1
    #retain: true
    
  # Will message (Broker sends "offline" if connection is lost)
  #will_message:
    #topic: homeassistant/genset/status
    #payload: "offline"
    #qos: 1
    #retain: true

#------------------------------------------------------
# Sensors & Text Sensors
sensor:
  - platform: internal_temperature
    id: pico_chip_temperature
    name: "Pico Chip Temperature"
    update_interval: 60s
    accuracy_decimals: 1

  # --- ADC INPUTS: ADC1 (GPIO27) and ADC2 (GPIO28) adjacent to AGND ---
  - platform: adc
    pin: GPIO27 # Pin 32 (ADC1) - Battery Voltage
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 60s
    unit_of_measurement: V
    accuracy_decimals: 1
    # lambda: return x * 5.0 / 4095.0 * 10.0; # Example scaling

  - platform: adc
    pin: GPIO28 # Pin 34 (ADC2) - Armed Status
    name: "Armed ADC"
    id: armed_adc 
    update_interval: 20s
    unit_of_measurement: V
    accuracy_decimals: 1

# --- Text Sensor to capture IP Address ---
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "Current IP Address"
      id: ip_address_sensor
      update_interval: 10s
      
# Text sensor to show MQTT status
  #- platform: template
    #name: "MQTT Status"
    #id: mqtt_status_sensor
    # Using the YAML Flow Block Scalar (|-): This guarantees the C++ is treated as raw text.
    #lambda: |- 
      #if (id(mqtt_client).connected) {
        #return "Connected";
      #} else {
        #return "Disconnected";
      #}
    #update_interval: 15s

  #---------------------------

  - platform: template
    name: "Generator Status"
    id: generator_status
    update_interval: 1s
    lambda: |-
      if (id(low_oil).state || id(over_temp).state || id(over_crank).state || id(over_speed).state || id(alarm_status).state) {
        return {"Alarm/Fault"};
      }
      if (id(gen_phase_1).state && id(gen_phase_2).state) {
        if (id(xfer_sw).state) {
          return {"Generating"};
        } else {
          return {"Running"};
        }
      }
      if (id(starting).state) {
        return {"Starting"};
      }
      if (id(auto_enabled).state) {
        if (id(mains).state) {
          return {"Standby"};
        } else {
          return {"Standby Outage"};
        }
      }
      if (id(mains).state) {
        return {"Mains Active (Man)"};
      }
      return {"Off/Manual"};
  #---------------------------
  # Battery state calculation
  - platform: template
    name: "Battery Status"
    id: batt_status
    icon: "mdi:battery-check"
    lambda: |-
      float v = id(battery_voltage).state;

      // 1. Critical Fault Check (Voltage below 6V or sensor error)
      if (std::isnan(v) || v < 6.0) {
        return {"Fault"};
      }

      // 2. High Voltage (Equalization/Deep Charging)
      if (v > 13.5) {
        return {"Equalize"};
      } else if (v > 12.6) {
        return {"Float Charge"};
      } else if (v > 12.1) {
        return {"Charging"};
      } 
      
      // 3. Resting Voltage (Standard Operation)
      else if (v >= 11.8) {
        return {"Full"};
      } else if (v >= 11.3) {
        return {"Good"};
      } else if (v >= 10.8) {
        return {"Medium"};
      } else if (v > 10.0) {
        return {"Low"};
      } 
      
      // 4. Depleted
      else {
        return {"Discharged"};
      }
    update_interval: 60s

#--------------------------------------------------------------------

interval:

  # publish state every 30 sec as a backup, it is also published 
  # if the sensor changes
  - interval: 30s # Refresh interval period
    then:
      # 1. Mains/Generator Status (Updated GPIO 18-21 Mappings)
      - binary_sensor.template.publish:
          id: alarm_status
          state: !lambda 'return id(alarm_status).state;'
      - binary_sensor.template.publish:
          id: gen_phase_2
          state: !lambda 'return id(gen_phase_2).state;'
      - binary_sensor.template.publish:
          id: gen_phase_1
          state: !lambda 'return id(gen_phase_1).state;'
      - binary_sensor.template.publish:
          id: mains
          state: !lambda 'return id(mains).state;'

      # 2. Control Logic Inputs (Updated GPIO 10-13 Mappings)
      - binary_sensor.template.publish:
          id: xfer_sw
          state: !lambda 'return id(xfer_sw).state;'
      - binary_sensor.template.publish:
          id: starting
          state: !lambda 'return id(starting).state;'
      - binary_sensor.template.publish:
          id: auto_enabled
          state: !lambda 'return id(auto_enabled).state;'
      - binary_sensor.template.publish:
          id: run_enabled
          state: !lambda 'return id(run_enabled).state;'

      # 3. Engine Status/Alarm LEDs (GPIO 6-9)
      - binary_sensor.template.publish:
          id: low_oil
          state: !lambda 'return id(low_oil).state;'
      - binary_sensor.template.publish:
          id: over_temp
          state: !lambda 'return id(over_temp).state;'
      - binary_sensor.template.publish:
          id: over_crank
          state: !lambda 'return id(over_crank).state;'
      - binary_sensor.template.publish:
          id: over_speed
          state: !lambda 'return id(over_speed).state;'

  #---------------------------------------
  # update icon if it changes
  - interval: 1s
    then:
      - lambda: |-
          std::string current_state = id(generator_status).state;
          static std::string last_sent_state = "";

          if (!current_state.empty() && current_state != last_sent_state) {
            const char* new_icon = "mdi:hand-back-left"; // Fallback

            // Use .find() to be safe against hidden spaces/formatting
            if      (current_state.find("Standby Outage") != std::string::npos) new_icon = "mdi:shield-check";
            else if (current_state.find("Standby") != std::string::npos)        new_icon = "mdi:power-plug";
            else if (current_state.find("Generating") != std::string::npos)     new_icon = "mdi:lightning-bolt";
            else if (current_state.find("Running") != std::string::npos)        new_icon = "mdi:lightning-bolt-outline";
            else if (current_state.find("Starting") != std::string::npos)       new_icon = "mdi:engine-outline";
            else if (current_state.find("Alarm") != std::string::npos)          new_icon = "mdi:alert-outline";

            id(generator_status).set_icon(new_icon);
            
            // This is the critical "Push" to Home Assistant
            id(generator_status).publish_state(current_state);
            
            last_sent_state = current_state;
            ESP_LOGD("icon_logic", "Matched icon %s for state %s", new_icon, current_state.c_str());
          }
#-------------------------------------------------------
# --- BINARY SENSORS ---
binary_sensor:

  # 1. Mains/Generator Status Sensors (GPIO 18-21)
  - platform: gpio
    pin:
      number: GPIO18
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Alarm"
    id: alarm_status

  - platform: gpio
    pin:
      number: GPIO19
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Gen Phase 2"
    id: gen_phase_2

  - platform: gpio
    pin:
      number: GPIO20
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Gen Phase 1"
    id: gen_phase_1

  - platform: gpio
    pin:
      number: GPIO21
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Mains"
    id: mains

  # 2. Control Logic Inputs (GPIO 10-13)
  - platform: gpio
    pin:
      number: GPIO10
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Transfer Switch"
    id: xfer_sw

  - platform: gpio
    pin:
      number: GPIO11
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Starting"
    id: starting

  - platform: gpio
    pin:
      number: GPIO12
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Auto Enabled"
    id: auto_enabled

  - platform: gpio
    pin:
      number: GPIO13
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Run Enabled"
    id: run_enabled

  # 3. Engine Status/Alarm LEDs (GPIO 6-9)
  - platform: gpio
    pin:
      number: GPIO6
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Low Oil"
    id: low_oil

  - platform: gpio
    pin:
      number: GPIO7
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Over Temp"
    id: over_temp

  - platform: gpio
    pin:
      number: GPIO8
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Over Crank"
    id: over_crank

  - platform: gpio
    pin:
      number: GPIO9
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Over Speed"
    id: over_speed

  # New Binary Sensor: ON when voltage is high (Armed)
  - platform: template
    name: "Armed"
    id: armed 
    # assumes cathode of led pulled to ground to illuminate
    lambda: return id(armed_adc).state < 1.0; 
    device_class: safety

#------------------------------------------------------
# Display Configuration: Pulled in from external file
<<: !include functions.yaml
