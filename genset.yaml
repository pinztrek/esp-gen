#genset.yaml
esphome:
  name: genset
  #friendly_name: genmon2

rp2040:
  board: rpipicow

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: "9f6aac9d5e98fb4ba34f158083f13970"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot in case wifi connection fails
  ap:
    ssid: "Blink Fallback Hotspot"
    password: "esphomepw"

  # --- On Connect Action for Internal LED ---
  # Turn it on upon connect, but it will be overridden by status_led
  #on_connect:
    #then:
      #- light.turn_on:
          #id: onboard_led_light
          #brightness: 100% 

# Does not work on pi pico yet
#captive_portal:

#-------------------------------------------------------
# Homeassistant I/O code
#output: 
  
#-------------------------------------------------------

status_led:
  #pin: LED
  pin:
    number: LED
    inverted: true
  

# --- LIGHT COMPONENTS ---
#light: 
  # LIGHT component for Pico W Status LED
  #- platform: status_led
    # The Pico W LED is controlled by the CYW43439 Wi-Fi chip.
    # Pin 32 or Pin LED control it
    #pin: GPIO32 
    #pin: LED 
    #name: "Pico Status LED"
    #id: onboard_led_light

#------------------------------------------------------
# MQTT Integration
#mqtt:
  #id: mqtt_client
  #broker: 172.16.30.41
  #port: 1883
  #username: esphome
  #password: !secret mqtt_password

  # additional params
  #topic_prefix: esphome

# Status configuration (using the documented structure)
  #status:
    #topic: homeassistant/status
    #update_interval: 60s # Publish status every 60 seconds (optional, but good practice)

# Birth message (Sends "online" when connected)
  #birth_message:
    #topic: homeassistant/genset/status
    #payload: "online"
    #qos: 1
    #retain: true
    
  # Will message (Broker sends "offline" if connection is lost)
  #will_message:
    #topic: homeassistant/genset/status
    #payload: "offline"
    #qos: 1
    #retain: true

#------------------------------------------------------
# Sensors & Text Sensors
sensor:
  - platform: internal_temperature
    id: pico_chip_temperature
    name: "Pico Chip Temperature"
    update_interval: 60s
    accuracy_decimals: 1

  # --- ADC INPUTS: ADC1 (GPIO27) and ADC2 (GPIO28) adjacent to AGND ---
  # --- Battery Voltage (10s High-Frequency Reporting) ---
  - platform: adc
    pin: GPIO27 
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 10s  # Samples every 10 seconds
    unit_of_measurement: V
    accuracy_decimals: 2
    filters:
      # Scaling for 68k/10k divider
      - multiply: 7.8
      
      # Smooths noise but reports every update
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1 # Set to 6 later for 60s reporting 

  - platform: adc
    pin: GPIO28 # Pin 34 (ADC2) - Armed Status
    name: "Armed ADC"
    id: armed_adc 
    update_interval: 20s
    unit_of_measurement: V
    accuracy_decimals: 1

# --- Text Sensor to capture IP Address ---
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "Current IP Address"
      id: ip_address_sensor
      update_interval: 10s
      
# Text sensor to show MQTT status
  #- platform: template
    #name: "MQTT Status"
    #id: mqtt_status_sensor
    # Using the YAML Flow Block Scalar (|-): This guarantees the C++ is treated as raw text.
    #lambda: |- 
      #if (id(mqtt_client).connected) {
        #return "Connected";
      #} else {
        #return "Disconnected";
      #}
    #update_interval: 15s

  #---------------------------
  - platform: template
    name: "Generator Status"
    id: generator_status
    update_interval: 1s
    lambda: |-
      // 1. CRITICAL: Faults always take top priority
      if (id(low_oil).state || id(over_temp).state || id(over_crank).state || id(over_speed).state || id(alarm_status).state) {
        return {"Alarm/Fault"};
      }

      // 2. GENERATING: Engine running AND Transfer Switch is closed
      if (id(gen_phase_1).state && id(gen_phase_2).state && id(xfer_sw).state) {
        return {"Generating"};
      }

      // 3. EXERCISE / COOLDOWN: Engine running, Xfer open, Utility is ON
      if (id(gen_phase_1).state && id(gen_phase_2).state && !id(xfer_sw).state && id(mains).state) {
        return {"Exercise"};
      }

      // 4. WARMUP: Engine running, Xfer open, Utility is OFF
      if (id(gen_phase_1).state && id(gen_phase_2).state && !id(xfer_sw).state && !id(mains).state) {
        return {"Warmup"};
      }

      // 5. STARTING: Starter motor engaged
      if (id(starting).state) {
        return {"Starting"};
      }

      // 6. STANDBY OUTAGE: Auto-mode ON, Utility is OFF
      if (id(auto_enabled).state && !id(mains).state) {
        return {"Standby Outage"};
      }

      // 7. STANDBY: Auto-mode ON, Utility is ON (Normal)
      if (id(auto_enabled).state && id(mains).state) {
        return {"Standby"};
      }

      // 8. MAINS MANUAL: Auto-mode OFF, Utility is ON
      if (!id(auto_enabled).state && id(mains).state) {
        return {"Mains Manual"};
      }

      // 9. OUTAGE MANUAL: Auto-mode OFF, Utility is OFF
      if (!id(auto_enabled).state && !id(mains).state) {
        return {"Outage Manual"};
      }

      // Absolute Fallback
      return {"Off/Manual"};


  #---------------------------
  # Battery state calculation

  - platform: template
    name: "Battery Status"
    id: batt_status
    icon: "mdi:battery-check"
    update_interval: 10s
    lambda: |-
      float v = id(battery_voltage).state;

      // 1. Critical Fault Check (Voltage below 2V or sensor error)
      if (std::isnan(v) || v < 2.0) {
        return {"Fault"};
      }

      // 2. High Voltage / Charging States
      if (v > 14.0) {
        return {"Over Chg"};
      } else if (v > 13.5) {
        return {"Equalize"};
      } else if (v > 12.6) {
        return {"Float Charge"};
      } else if (v > 12.1) {
        return {"Charging"};
      }

      // 3. Resting Voltage (Standard Operation)
      else if (v >= 11.8) {
        return {"Full"};
      } else if (v >= 11.3) {
        return {"Good"};
      } else if (v >= 10.8) {
        return {"Medium"};
      } else if (v > 10.0) {
        return {"Low"};
      }

      // 4. Depleted
      else {
        return {"Discharged"};
      }

#--------------------------------------------------------------------

interval:

  # publish state every 30 sec as a backup, it is also published 
  # if the sensor changes
  - interval: 30s # Refresh interval period
    then:
      # 1. Mains/Generator Status (Updated GPIO 18-21 Mappings)
      - binary_sensor.template.publish:
          id: alarm_status
          state: !lambda 'return id(alarm_status).state;'
      - binary_sensor.template.publish:
          id: gen_phase_2
          state: !lambda 'return id(gen_phase_2).state;'
      - binary_sensor.template.publish:
          id: gen_phase_1
          state: !lambda 'return id(gen_phase_1).state;'
      - binary_sensor.template.publish:
          id: mains
          state: !lambda 'return id(mains).state;'

      # 2. Control Logic Inputs (Updated GPIO 10-13 Mappings)
      - binary_sensor.template.publish:
          id: xfer_sw
          state: !lambda 'return id(xfer_sw).state;'
      - binary_sensor.template.publish:
          id: starting
          state: !lambda 'return id(starting).state;'
      - binary_sensor.template.publish:
          id: auto_enabled
          state: !lambda 'return id(auto_enabled).state;'
      - binary_sensor.template.publish:
          id: run_enabled
          state: !lambda 'return id(run_enabled).state;'

      # 3. Engine Status/Alarm LEDs (GPIO 6-9)
      - binary_sensor.template.publish:
          id: low_oil
          state: !lambda 'return id(low_oil).state;'
      - binary_sensor.template.publish:
          id: over_temp
          state: !lambda 'return id(over_temp).state;'
      - binary_sensor.template.publish:
          id: over_crank
          state: !lambda 'return id(over_crank).state;'
      - binary_sensor.template.publish:
          id: over_speed
          state: !lambda 'return id(over_speed).state;'

#-------------------------------------------------------
# --- BINARY SENSORS ---
binary_sensor:

  # 1. Mains/Generator Status Sensors (GPIO 18-21)
  - platform: gpio
    pin:
      number: GPIO18
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Alarm"
    id: alarm_status

  - platform: gpio
    pin:
      number: GPIO19
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Gen Phase 2"
    id: gen_phase_2

  - platform: gpio
    pin:
      number: GPIO20
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Gen Phase 1"
    id: gen_phase_1

  - platform: gpio
    pin:
      number: GPIO21
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Mains"
    id: mains

  # 2. Control Logic Inputs (GPIO 10-13)
  - platform: gpio
    pin:
      number: GPIO10
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Transfer Switch"
    id: xfer_sw

  - platform: gpio
    pin:
      number: GPIO11
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Starting"
    id: starting

  - platform: gpio
    pin:
      number: GPIO12
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Auto Enabled"
    id: auto_enabled

  - platform: gpio
    pin:
      number: GPIO13
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Run Enabled"
    id: run_enabled

  # 3. Engine Status/Alarm LEDs (GPIO 6-9)
  - platform: gpio
    pin:
      number: GPIO6
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Low Oil"
    id: low_oil

  - platform: gpio
    pin:
      number: GPIO7
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Over Temp"
    id: over_temp

  - platform: gpio
    pin:
      number: GPIO8
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Over Crank"
    id: over_crank

  - platform: gpio
    pin:
      number: GPIO9
      mode: INPUT_PULLUP
      inverted: true # Active Low
    name: "Over Speed"
    id: over_speed

  # New Binary Sensor: ON when voltage is high (Armed)
  - platform: template
    name: "Armed"
    id: armed 
    # assumes cathode of led pulled to ground to illuminate
    lambda: return id(armed_adc).state < 1.0; 
    device_class: safety

#------------------------------------------------------
# Display Configuration: Pulled in from external file
<<: !include functions.yaml
